module str-reader

imports 
  libstrc
  libstratego-lib
  libstratego-sglr // added
  libstratego-xtc // added
  libstratego-gpp
  libstratego-aterm
  trans-str
strategies
	// file is FILE
	//test-str-parse =  parse-stratego-file //ps-parse-module-trm
	//test-str-parse =  ps-parse-module-trm
	//test-str-parse =  parse-stratego-trm(|["-i", <id>, "--preserve-positions"])

rules
	/*
	// throws critical error
	// [ Test | critical ] Old-style asfix position annotation not supported on this platform; use asfix-anno-location instead
	test-str-parse:
	f@FILE(filename) -> out
	with
		out := <ps-set-preserve-positions> "yes"; <ps-parse-module-trm> f 
		*/
		

rules
	
	// current term is string
	// writes the string to the absolute-location
  write-stratego(|absolute-location) :
   source-code -> absolute-location
   //where <debug(!"write-stratego to ")> absolute-location
   where
   	<dirname> absolute-location => dir
   	//; debug(!"dirname: ")
   	; check-dir // check if dir exists, if not create the complete path otherwise write-to-file will fail 
   	; write-to-file(|absolute-location, source-code)
  
  strategies

  // accept a (filename, source-code)*
  // filename is relative to the base-dir
  write-files-relative(|base-dir):
    transform-results* ->
      writes*
    //  <schrijf (|"kaas", x)>
      with
      	writes* := <map(write-to-file-relative(|base-dir))> transform-results*
      	
      	
  // filename is relative to base-dir
  // filename should correspond to the package structure
  write-to-file-relative(|base-dir) :
  	(filename, content) -> filename
  	where
  	<concat-strings> [base-dir, "/", filename] => absolutepath
  	; <dirname> absolutepath => dir
  	; check-dir
  	; write-to-file(|absolutepath, content)
	
	// assume the directory exists
	// current term is ignored
	write-to-file(|filename, contents) = 
		handle := <fopen> (filename, "w")
		; <fputs> (contents, handle)
		; fclose


	// assume directory exists
	// current term is ignored
	// returns the result of <fopen> (Stream)
	// howto write to the file:
	// <fputs> (contents, handle)
	get-file-handle(|filename) =
		handle := <fopen> (filename, "w")
		
	// writes contents to the file-handle
	// returns the Stream
	// cannot call fflush Primitive not defined: SSL_fflush when using java
	write-contents-to-handle(|file-handle, contents) = 	<fputs> (contents, file-handle) //; fflush
	
	// closes the file-handle Stream
	close-file-handle(|file-handle) = <fclose> file-handle
		
	// check if the current term is a directory and it exists
	// if not, create the full path
	check-dir =
		?directory
		//; debug(!"check-dir: ")
		; parent-dir := <dirname> directory
		; !directory
		; (file-exists ; filemode ; isdir) // if isdir fails, mkdir
		  <+ (create-dir)
	
	// current term should be a directory path
	// creates the full directory path	  
	create-dir =
		?directory
		//; debug(!"create dir: ")
		; parent-dir := <dirname> directory
		; <check-dir> parent-dir
		// check if the parent dir exists
		; try(!directory; mkdir//; debug(!"mkdir succes")
		  )
	
  // current term should be a Stratego ast
  // converts ast to a stratego program
  pp-stratego-ast = 
  	pp-stratego-string
	
	
strategies // parsing stratego
	
  // ignore current term
  // returns aterm
  parse-stratego-with-locations(|file-path) =
	!FILE(file-path) 
	; parse-stratego-trm(| [ "-i", file-path
	  , "--preserve-locations" // added in rev:21513 of strategoxt, use a build from source
	    ]
	    )
	 
  // ignore current term, just return the ast of a stratego program	
  get-anno-ast(|file-path) = 
      where(
      	tbl-path := <get-tbl-path>
        ; <ReadFromFile> tbl-path 
        ; open-parse-table => tbl
        //; <debug(!"file-path: ")> file-path
        ; <read-text-file> file-path => file
        //; <debug(!"read file from: ")> file-path
      )
    ; <parse-with-asfix-anno(|tbl)> file
      
  get-tbl-path = <concat-strings> [<get-project-dir>, "/", "include/Test.tbl"] 

  // current term should be result of: <read-text-file> file-path
  // with file-path the path to a text file    
  parse-with-asfix-anno(|tbl) =
    parse-string-pt(on-parse-error|tbl)
    ; asfix-anno-location
    ; implode-asfix
      
  on-parse-error = debug(!"Parse error: ")
  
strategies // directory walking
	
		// fails if the current path does not have the ".str"-extension or when it is a directory
	is-stratego-file = has-extension(|"str"); file-exists; filemode; not(isdir)
	
	// returns a list of paths, for which the strategy s holds.
	// Strategy s should make the distinction between files and directories if needed,
	// as s is applied to all elements in a directory (the elements returned by <readdir>)
	//
	// current term should be a String pointing to a directory name
	walk-dir(s) = 
		?base-dir
		; readdir //
		; fullpaths* := <map(prefix-with(|base-dir))> // prefix the file name with the base-dir
		//; debug(!"list-dirs: ")
		; has-str* := <filter(s)>
		//; debug(!"list str: ")
		; dirs-only* := <filter-dirs> fullpaths* // keep directories
		; str-in-subdirs* := <map(walk-dir(s)) ; flatten-list> dirs-only*
		//; debug(!"str-in-subdirs* ")
		; <flatten-list> [str-in-subdirs*, has-str*]
		// walk over the directories
	
	// prefix the current file name with a path prefix
	prefix-with(|prefix) :
		filename -> path
		with
			path := <concat-strings> [prefix, "/", filename]
	
	// in the list of paths, only keep the ones that are directories
	filter-dirs :
		paths* -> dirs*
		with
		 dirs* := <filter(file-exists ; filemode ; isdir)> paths*
		 //< list-dirs-in-dir + ![]
	